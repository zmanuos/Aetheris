{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v12.2.0 (2025-04-07)\n * @module highcharts/modules/marker-clusters\n * @requires highcharts\n *\n * Marker clusters module for Highcharts\n *\n * (c) 2010-2025 Wojciech Chmiel\n *\n * License: www.highcharts.com/license\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"highcharts\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"highcharts/modules/marker-clusters\", [[\"highcharts/highcharts\"]], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"highcharts/modules/marker-clusters\"] = factory(require(\"highcharts\"));\n\telse\n\t\troot[\"Highcharts\"] = factory(root[\"Highcharts\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__944__) {\nreturn /******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 944:\n/***/ (function(module) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__944__;\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t!function() {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__webpack_require__.n = function(module) {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\tfunction() { return module['default']; } :\n/******/ \t\t\t\tfunction() { return module; };\n/******/ \t\t\t__webpack_require__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t!function() {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__webpack_require__.d = function(exports, definition) {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t}();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t!function() {\n/******/ \t\t__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }\n/******/ \t}();\n/******/ \t\n/************************************************************************/\nvar __webpack_exports__ = {};\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"default\": function() { return /* binding */ marker_clusters_src; }\n});\n\n// EXTERNAL MODULE: external {\"amd\":[\"highcharts/highcharts\"],\"commonjs\":[\"highcharts\"],\"commonjs2\":[\"highcharts\"],\"root\":[\"Highcharts\"]}\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_ = __webpack_require__(944);\nvar highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default = /*#__PURE__*/__webpack_require__.n(highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_);\n;// ./code/es5/es-modules/Extensions/MarkerClusters/MarkerClusterDefaults.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2025 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Options for marker clusters, the concept of sampling the data\n * values into larger blocks in order to ease readability and\n * increase performance of the JavaScript charts.\n *\n * Note: marker clusters module is not working with `boost`\n * and `draggable-points` modules.\n *\n * The marker clusters feature requires the marker-clusters.js\n * file to be loaded, found in the modules directory of the download\n * package, or online at [code.highcharts.com/modules/marker-clusters.js\n * ](code.highcharts.com/modules/marker-clusters.js).\n *\n * @sample maps/marker-clusters/europe\n *         Maps marker clusters\n * @sample highcharts/marker-clusters/basic\n *         Scatter marker clusters\n * @sample maps/marker-clusters/optimized-kmeans\n *         Marker clusters with colorAxis\n *\n * @product      highcharts highmaps\n * @since 8.0.0\n * @optionparent plotOptions.scatter.cluster\n *\n * @private\n */\nvar cluster = {\n    /**\n     * Whether to enable the marker-clusters module.\n     *\n     * @sample maps/marker-clusters/basic\n     *         Maps marker clusters\n     * @sample highcharts/marker-clusters/basic\n     *         Scatter marker clusters\n     */\n    enabled: false,\n    /**\n     * When set to `false` prevent cluster overlapping - this option\n     * works only when `layoutAlgorithm.type = \"grid\"`.\n     *\n     * @sample highcharts/marker-clusters/grid\n     *         Prevent overlapping\n     */\n    allowOverlap: true,\n    /**\n     * Options for the cluster marker animation.\n     * @type    {boolean|Partial<Highcharts.AnimationOptionsObject>}\n     * @default { \"duration\": 500 }\n     */\n    animation: {\n        /** @ignore-option */\n        duration: 500\n    },\n    /**\n     * Zoom the plot area to the cluster points range when a cluster is clicked.\n     */\n    drillToCluster: true,\n    /**\n     * The minimum amount of points to be combined into a cluster.\n     * This value has to be greater or equal to 2.\n     *\n     * @sample highcharts/marker-clusters/basic\n     *         At least three points in the cluster\n     */\n    minimumClusterSize: 2,\n    /**\n     * Options for layout algorithm. Inside there\n     * are options to change the type of the algorithm, gridSize,\n     * distance or iterations.\n     */\n    layoutAlgorithm: {\n        /**\n         * Type of the algorithm used to combine points into a cluster.\n         * There are three available algorithms:\n         *\n         * 1) `grid` - grid-based clustering technique. Points are assigned\n         * to squares of set size depending on their position on the plot\n         * area. Points inside the grid square are combined into a cluster.\n         * The grid size can be controlled by `gridSize` property\n         * (grid size changes at certain zoom levels).\n         *\n         * 2) `kmeans` - based on K-Means clustering technique. In the\n         * first step, points are divided using the grid method (distance\n         * property is a grid size) to find the initial amount of clusters.\n         * Next, each point is classified by computing the distance between\n         * each cluster center and that point. When the closest cluster\n         * distance is lower than distance property set by a user the point\n         * is added to this cluster otherwise is classified as `noise`. The\n         * algorithm is repeated until each cluster center not change its\n         * previous position more than one pixel. This technique is more\n         * accurate but also more time consuming than the `grid` algorithm,\n         * especially for big datasets.\n         *\n         * 3) `optimizedKmeans` - based on K-Means clustering technique. This\n         * algorithm uses k-means algorithm only on the chart initialization\n         * or when chart extremes have greater range than on initialization.\n         * When a chart is redrawn the algorithm checks only clustered points\n         * distance from the cluster center and rebuild it when the point is\n         * spaced enough to be outside the cluster. It provides performance\n         * improvement and more stable clusters position yet can be used rather\n         * on small and sparse datasets.\n         *\n         * By default, the algorithm depends on visible quantity of points\n         * and `kmeansThreshold`. When there are more visible points than the\n         * `kmeansThreshold` the `grid` algorithm is used, otherwise `kmeans`.\n         *\n         * The custom clustering algorithm can be added by assigning a callback\n         * function as the type property. This function takes an array of\n         * `processedXData`, `processedYData`, `processedXData` indexes and\n         * `layoutAlgorithm` options as arguments and should return an object\n         * with grouped data.\n         *\n         * The algorithm should return an object like that:\n         * <pre>{\n         *  clusterId1: [{\n         *      x: 573,\n         *      y: 285,\n         *      index: 1 // point index in the data array\n         *  }, {\n         *      x: 521,\n         *      y: 197,\n         *      index: 2\n         *  }],\n         *  clusterId2: [{\n         *      ...\n         *  }]\n         *  ...\n         * }</pre>\n         *\n         * `clusterId` (example above - unique id of a cluster or noise)\n         * is an array of points belonging to a cluster. If the\n         * array has only one point or fewer points than set in\n         * `cluster.minimumClusterSize` it won't be combined into a cluster.\n         *\n         * @sample maps/marker-clusters/optimized-kmeans\n         *         Optimized K-Means algorithm\n         * @sample highcharts/marker-clusters/kmeans\n         *         K-Means algorithm\n         * @sample highcharts/marker-clusters/grid\n         *         Grid algorithm\n         * @sample maps/marker-clusters/custom-alg\n         *         Custom algorithm\n         *\n         * @type {string|Function}\n         * @see [cluster.minimumClusterSize](#plotOptions.scatter.cluster.minimumClusterSize)\n         * @apioption plotOptions.scatter.cluster.layoutAlgorithm.type\n         */\n        /**\n         * When `type` is set to the `grid`,\n         * `gridSize` is a size of a grid square element either as a number\n         * defining pixels, or a percentage defining a percentage\n         * of the plot area width.\n         *\n         * @type    {number|string}\n         */\n        gridSize: 50,\n        /**\n         * When `type` is set to `kmeans`,\n         * `iterations` are the number of iterations that this algorithm will be\n         * repeated to find clusters positions.\n         *\n         * @type    {number}\n         * @apioption plotOptions.scatter.cluster.layoutAlgorithm.iterations\n         */\n        /**\n         * When `type` is set to `kmeans`,\n         * `distance` is a maximum distance between point and cluster center\n         * so that this point will be inside the cluster. The distance\n         * is either a number defining pixels or a percentage\n         * defining a percentage of the plot area width.\n         *\n         * @type    {number|string}\n         */\n        distance: 40,\n        /**\n         * When `type` is set to `undefined` and there are more visible points\n         * than the kmeansThreshold the `grid` algorithm is used to find\n         * clusters, otherwise `kmeans`. It ensures good performance on\n         * large datasets and better clusters arrangement after the zoom.\n         */\n        kmeansThreshold: 100\n    },\n    /**\n     * Options for the cluster marker.\n     * @type      {Highcharts.PointMarkerOptionsObject}\n     * @extends   plotOptions.series.marker\n     * @excluding enabledThreshold, states\n     */\n    marker: {\n        /** @internal */\n        symbol: 'cluster',\n        /** @internal */\n        radius: 15,\n        /** @internal */\n        lineWidth: 0,\n        /** @internal */\n        lineColor: \"#ffffff\" /* Palette.backgroundColor */\n    },\n    /**\n     * Fires when the cluster point is clicked and `drillToCluster` is enabled.\n     * One parameter, `event`, is passed to the function. The default action\n     * is to zoom to the cluster points range. This can be prevented\n     * by calling `event.preventDefault()`.\n     *\n     * @type      {Highcharts.MarkerClusterDrillCallbackFunction}\n     * @product   highcharts highmaps\n     * @see [cluster.drillToCluster](#plotOptions.scatter.cluster.drillToCluster)\n     * @apioption plotOptions.scatter.cluster.events.drillToCluster\n     */\n    /**\n     * An array defining zones within marker clusters.\n     *\n     * In styled mode, the color zones are styled with the\n     * `.highcharts-cluster-zone-{n}` class, or custom\n     * classed from the `className`\n     * option.\n     *\n     * @sample highcharts/marker-clusters/basic\n     *         Marker clusters zones\n     * @sample maps/marker-clusters/custom-alg\n     *         Zones on maps\n     *\n     * @type      {Array<*>}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones\n     */\n    /**\n     * Styled mode only. A custom class name for the zone.\n     *\n     * @sample highcharts/css/color-zones/\n     *         Zones styled by class name\n     *\n     * @type      {string}\n     * @apioption plotOptions.scatter.cluster.zones.className\n     */\n    /**\n     * Settings for the cluster marker belonging to the zone.\n     *\n     * @see [cluster.marker](#plotOptions.scatter.cluster.marker)\n     * @extends   plotOptions.scatter.cluster.marker\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.marker\n     */\n    /**\n     * The value where the zone starts.\n     *\n     * @type      {number}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.from\n     */\n    /**\n     * The value where the zone ends.\n     *\n     * @type      {number}\n     * @product   highcharts highmaps\n     * @apioption plotOptions.scatter.cluster.zones.to\n     */\n    /**\n     * The fill color of the cluster marker in hover state. When\n     * `undefined`, the series' or point's fillColor for normal\n     * state is used.\n     *\n     * @type      {Highcharts.ColorType}\n     * @apioption plotOptions.scatter.cluster.states.hover.fillColor\n     */\n    /**\n     * Options for the cluster data labels.\n     * @type    {Highcharts.DataLabelsOptions}\n     */\n    dataLabels: {\n        /** @internal */\n        enabled: true,\n        /** @internal */\n        format: '{point.clusterPointsAmount}',\n        /** @internal */\n        verticalAlign: 'middle',\n        /** @internal */\n        align: 'center',\n        /** @internal */\n        style: {\n            color: 'contrast'\n        },\n        /** @internal */\n        inside: true\n    }\n};\nvar tooltip = {\n    /**\n     * The HTML of the cluster point's in the tooltip. Works only with\n     * marker-clusters module and analogously to\n     * [pointFormat](#tooltip.pointFormat).\n     *\n     * The cluster tooltip can be also formatted using\n     * `tooltip.formatter` callback function and `point.isCluster` flag.\n     *\n     * @sample highcharts/marker-clusters/grid\n     *         Format tooltip for cluster points.\n     *\n     * @sample maps/marker-clusters/europe/\n     *         Format tooltip for clusters using tooltip.formatter\n     *\n     * @type      {string}\n     * @default   Clustered points: {point.clusterPointsAmount}\n     * @apioption tooltip.clusterFormat\n     */\n    clusterFormat: '<span>Clustered points: ' +\n        '{point.clusterPointsAmount}</span><br/>'\n};\n/* *\n *\n *  Default Export\n *\n * */\nvar MarkerClusterDefaults = {\n    cluster: cluster,\n    tooltip: tooltip\n};\n/* harmony default export */ var MarkerClusters_MarkerClusterDefaults = (MarkerClusterDefaults);\n\n;// ./code/es5/es-modules/Data/ColumnUtils.js\n/* *\n *\n *  (c) 2020-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Dawid Dragula\n *\n * */\nvar __spreadArray = (undefined && undefined.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\n/**\n * Utility functions for columns that can be either arrays or typed arrays.\n * @private\n */\nvar ColumnUtils;\n(function (ColumnUtils) {\n    /* *\n    *\n    *  Declarations\n    *\n    * */\n    /* *\n    *\n    * Functions\n    *\n    * */\n    /**\n     * Sets the length of the column array.\n     *\n     * @param {DataTable.Column} column\n     * Column to be modified.\n     *\n     * @param {number} length\n     * New length of the column.\n     *\n     * @param {boolean} asSubarray\n     * If column is a typed array, return a subarray instead of a new array. It\n     * is faster `O(1)`, but the entire buffer will be kept in memory until all\n     * views to it are destroyed. Default is `false`.\n     *\n     * @return {DataTable.Column}\n     * Modified column.\n     *\n     * @private\n     */\n    function setLength(column, length, asSubarray) {\n        if (Array.isArray(column)) {\n            column.length = length;\n            return column;\n        }\n        return column[asSubarray ? 'subarray' : 'slice'](0, length);\n    }\n    ColumnUtils.setLength = setLength;\n    /**\n     * Splices a column array.\n     *\n     * @param {DataTable.Column} column\n     * Column to be modified.\n     *\n     * @param {number} start\n     * Index at which to start changing the array.\n     *\n     * @param {number} deleteCount\n     * An integer indicating the number of old array elements to remove.\n     *\n     * @param {boolean} removedAsSubarray\n     * If column is a typed array, return a subarray instead of a new array. It\n     * is faster `O(1)`, but the entire buffer will be kept in memory until all\n     * views to it are destroyed. Default is `true`.\n     *\n     * @param {Array<number>|TypedArray} items\n     * The elements to add to the array, beginning at the start index. If you\n     * don't specify any elements, `splice()` will only remove elements from the\n     * array.\n     *\n     * @return {SpliceResult}\n     * Object containing removed elements and the modified column.\n     *\n     * @private\n     */\n    function splice(column, start, deleteCount, removedAsSubarray, items) {\n        if (items === void 0) { items = []; }\n        if (Array.isArray(column)) {\n            if (!Array.isArray(items)) {\n                items = Array.from(items);\n            }\n            return {\n                removed: column.splice.apply(column, __spreadArray([start, deleteCount], items, false)),\n                array: column\n            };\n        }\n        var Constructor = Object.getPrototypeOf(column)\n                .constructor;\n        var removed = column[removedAsSubarray ? 'subarray' : 'slice'](start,\n            start + deleteCount);\n        var newLength = column.length - deleteCount + items.length;\n        var result = new Constructor(newLength);\n        result.set(column.subarray(0, start), 0);\n        result.set(items, start);\n        result.set(column.subarray(start + deleteCount), start + items.length);\n        return {\n            removed: removed,\n            array: result\n        };\n    }\n    ColumnUtils.splice = splice;\n})(ColumnUtils || (ColumnUtils = {}));\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ var Data_ColumnUtils = (ColumnUtils);\n\n;// ./code/es5/es-modules/Data/DataTableCore.js\n/* *\n *\n *  (c) 2009-2025 Highsoft AS\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n *  Authors:\n *  - Sophie Bremer\n *  - Gøran Slettemark\n *  - Torstein Hønsi\n *\n * */\n\n\nvar setLength = Data_ColumnUtils.setLength, splice = Data_ColumnUtils.splice;\n\nvar fireEvent = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).fireEvent, objectEach = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).objectEach, uniqueKey = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).uniqueKey;\n/* *\n *\n *  Class\n *\n * */\n/**\n * Class to manage columns and rows in a table structure. It provides methods\n * to add, remove, and manipulate columns and rows, as well as to retrieve data\n * from specific cells.\n *\n * @class\n * @name Highcharts.DataTable\n *\n * @param {Highcharts.DataTableOptions} [options]\n * Options to initialize the new DataTable instance.\n */\nvar DataTableCore = /** @class */ (function () {\n    /**\n     * Constructs an instance of the DataTable class.\n     *\n     * @example\n     * const dataTable = new Highcharts.DataTableCore({\n     *   columns: {\n     *     year: [2020, 2021, 2022, 2023],\n     *     cost: [11, 13, 12, 14],\n     *     revenue: [12, 15, 14, 18]\n     *   }\n     * });\n\n     *\n     * @param {Highcharts.DataTableOptions} [options]\n     * Options to initialize the new DataTable instance.\n     */\n    function DataTableCore(options) {\n        if (options === void 0) { options = {}; }\n        var _this = this;\n        /**\n         * Whether the ID was automatic generated or given in the constructor.\n         *\n         * @name Highcharts.DataTable#autoId\n         * @type {boolean}\n         */\n        this.autoId = !options.id;\n        this.columns = {};\n        /**\n         * ID of the table for identification purposes.\n         *\n         * @name Highcharts.DataTable#id\n         * @type {string}\n         */\n        this.id = (options.id || uniqueKey());\n        this.modified = this;\n        this.rowCount = 0;\n        this.versionTag = uniqueKey();\n        var rowCount = 0;\n        objectEach(options.columns || {}, function (column, columnName) {\n            _this.columns[columnName] = column.slice();\n            rowCount = Math.max(rowCount, column.length);\n        });\n        this.applyRowCount(rowCount);\n    }\n    /* *\n     *\n     *  Functions\n     *\n     * */\n    /**\n     * Applies a row count to the table by setting the `rowCount` property and\n     * adjusting the length of all columns.\n     *\n     * @private\n     * @param {number} rowCount The new row count.\n     */\n    DataTableCore.prototype.applyRowCount = function (rowCount) {\n        var _this = this;\n        this.rowCount = rowCount;\n        objectEach(this.columns, function (column, columnName) {\n            if (column.length !== rowCount) {\n                _this.columns[columnName] = setLength(column, rowCount);\n            }\n        });\n    };\n    /**\n     * Delete rows. Simplified version of the full\n     * `DataTable.deleteRows` method.\n     *\n     * @param {number} rowIndex\n     * The start row index\n     *\n     * @param {number} [rowCount=1]\n     * The number of rows to delete\n     *\n     * @return {void}\n     *\n     * @emits #afterDeleteRows\n     */\n    DataTableCore.prototype.deleteRows = function (rowIndex, rowCount) {\n        var _this = this;\n        if (rowCount === void 0) { rowCount = 1; }\n        if (rowCount > 0 && rowIndex < this.rowCount) {\n            var length_1 = 0;\n            objectEach(this.columns, function (column, columnName) {\n                _this.columns[columnName] =\n                    splice(column, rowIndex, rowCount).array;\n                length_1 = column.length;\n            });\n            this.rowCount = length_1;\n        }\n        fireEvent(this, 'afterDeleteRows', { rowIndex: rowIndex, rowCount: rowCount });\n        this.versionTag = uniqueKey();\n    };\n    /**\n     * Fetches the given column by the canonical column name. Simplified version\n     * of the full `DataTable.getRow` method, always returning by reference.\n     *\n     * @param {string} columnName\n     * Name of the column to get.\n     *\n     * @return {Highcharts.DataTableColumn|undefined}\n     * A copy of the column, or `undefined` if not found.\n     */\n    DataTableCore.prototype.getColumn = function (columnName, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        return this.columns[columnName];\n    };\n    /**\n     * Retrieves all or the given columns. Simplified version of the full\n     * `DataTable.getColumns` method, always returning by reference.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Highcharts.DataTableColumnCollection}\n     * Collection of columns. If a requested column was not found, it is\n     * `undefined`.\n     */\n    DataTableCore.prototype.getColumns = function (columnNames, \n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    asReference) {\n        var _this = this;\n        return (columnNames || Object.keys(this.columns)).reduce(function (columns, columnName) {\n            columns[columnName] = _this.columns[columnName];\n            return columns;\n        }, {});\n    };\n    /**\n     * Retrieves the row at a given index.\n     *\n     * @param {number} rowIndex\n     * Row index to retrieve. First row has index 0.\n     *\n     * @param {Array<string>} [columnNames]\n     * Column names to retrieve.\n     *\n     * @return {Record<string, number|string|undefined>|undefined}\n     * Returns the row values, or `undefined` if not found.\n     */\n    DataTableCore.prototype.getRow = function (rowIndex, columnNames) {\n        var _this = this;\n        return (columnNames || Object.keys(this.columns)).map(function (key) { var _a; return (_a = _this.columns[key]) === null || _a === void 0 ? void 0 : _a[rowIndex]; });\n    };\n    /**\n     * Sets cell values for a column. Will insert a new column, if not found.\n     *\n     * @param {string} columnName\n     * Column name to set.\n     *\n     * @param {Highcharts.DataTableColumn} [column]\n     * Values to set in the column.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. (Default: 0)\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    DataTableCore.prototype.setColumn = function (columnName, column, rowIndex, eventDetail) {\n        var _a;\n        if (column === void 0) { column = []; }\n        if (rowIndex === void 0) { rowIndex = 0; }\n        this.setColumns((_a = {}, _a[columnName] = column, _a), rowIndex, eventDetail);\n    };\n    /**\n     * Sets cell values for multiple columns. Will insert new columns, if not\n     * found. Simplified version of the full `DataTableCore.setColumns`, limited\n     * to full replacement of the columns (undefined `rowIndex`).\n     *\n     * @param {Highcharts.DataTableColumnCollection} columns\n     * Columns as a collection, where the keys are the column names.\n     *\n     * @param {number} [rowIndex]\n     * Index of the first row to change. Ignored in the `DataTableCore`, as it\n     * always replaces the full column.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #setColumns\n     * @emits #afterSetColumns\n     */\n    DataTableCore.prototype.setColumns = function (columns, rowIndex, eventDetail) {\n        var _this = this;\n        var rowCount = this.rowCount;\n        objectEach(columns, function (column, columnName) {\n            _this.columns[columnName] = column.slice();\n            rowCount = column.length;\n        });\n        this.applyRowCount(rowCount);\n        if (!(eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.silent)) {\n            fireEvent(this, 'afterSetColumns');\n            this.versionTag = uniqueKey();\n        }\n    };\n    /**\n     * Sets cell values of a row. Will insert a new row if no index was\n     * provided, or if the index is higher than the total number of table rows.\n     * A simplified version of the full `DateTable.setRow`, limited to objects.\n     *\n     * @param {Record<string, number|string|undefined>} row\n     * Cell values to set.\n     *\n     * @param {number} [rowIndex]\n     * Index of the row to set. Leave `undefined` to add as a new row.\n     *\n     * @param {boolean} [insert]\n     * Whether to insert the row at the given index, or to overwrite the row.\n     *\n     * @param {Record<string, (boolean|number|string|null|undefined)>} [eventDetail]\n     * Custom information for pending events.\n     *\n     * @emits #afterSetRows\n     */\n    DataTableCore.prototype.setRow = function (row, rowIndex, insert, eventDetail) {\n        if (rowIndex === void 0) { rowIndex = this.rowCount; }\n        var columns = this.columns,\n            indexRowCount = insert ? this.rowCount + 1 : rowIndex + 1;\n        objectEach(row, function (cellValue, columnName) {\n            var column = columns[columnName] ||\n                    (eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.addColumns) !== false && new Array(indexRowCount);\n            if (column) {\n                if (insert) {\n                    column = splice(column, rowIndex, 0, true, [cellValue]).array;\n                }\n                else {\n                    column[rowIndex] = cellValue;\n                }\n                columns[columnName] = column;\n            }\n        });\n        if (indexRowCount > this.rowCount) {\n            this.applyRowCount(indexRowCount);\n        }\n        if (!(eventDetail === null || eventDetail === void 0 ? void 0 : eventDetail.silent)) {\n            fireEvent(this, 'afterSetRows');\n            this.versionTag = uniqueKey();\n        }\n    };\n    return DataTableCore;\n}());\n/* *\n *\n *  Default Export\n *\n * */\n/* harmony default export */ var Data_DataTableCore = (DataTableCore);\n/* *\n *\n *  API Declarations\n *\n * */\n/**\n * A typed array.\n * @typedef {Int8Array|Uint8Array|Uint8ClampedArray|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array|Float64Array} Highcharts.TypedArray\n * //**\n * A column of values in a data table.\n * @typedef {Array<boolean|null|number|string|undefined>|Highcharts.TypedArray} Highcharts.DataTableColumn\n */ /**\n* A collection of data table columns defined by a object where the key is the\n* column name and the value is an array of the column values.\n* @typedef {Record<string, Highcharts.DataTableColumn>} Highcharts.DataTableColumnCollection\n*/\n/**\n * Options for the `DataTable` or `DataTableCore` classes.\n * @interface Highcharts.DataTableOptions\n */ /**\n* The column options for the data table. The columns are defined by an object\n* where the key is the column ID and the value is an array of the column\n* values.\n*\n* @name Highcharts.DataTableOptions.columns\n* @type {Highcharts.DataTableColumnCollection|undefined}\n*/ /**\n* Custom ID to identify the new DataTable instance.\n*\n* @name Highcharts.DataTableOptions.id\n* @type {string|undefined}\n*/\n(''); // Keeps doclets above in JS file\n\n;// ./code/es5/es-modules/Extensions/MarkerClusters/MarkerClusterScatter.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2025 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n\nvar animObject = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).animObject;\n\n\nvar clusterDefaults = MarkerClusters_MarkerClusterDefaults.cluster;\n\nvar addEvent = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).addEvent, defined = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).defined, error = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).error, isArray = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).isArray, isFunction = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).isFunction, isObject = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).isObject, isNumber = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).isNumber, merge = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).merge, MarkerClusterScatter_objectEach = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).objectEach, relativeLength = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).relativeLength, syncTimeout = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).syncTimeout;\n/* *\n *\n *  Constants\n *\n * */\nvar markerClusterAlgorithms = {\n    grid: function (dataX, dataY, dataIndexes, options) {\n        var _a;\n        var series = this,\n            grid = {},\n            gridOffset = series.getGridOffset(),\n            scaledGridSize = series.getScaledGridSize(options);\n        var x,\n            y,\n            gridX,\n            gridY,\n            key,\n            i;\n        for (i = 0; i < dataX.length; i++) {\n            var p = valuesToPixels(series, { x: dataX[i],\n                y: dataY[i] });\n            x = p.x - gridOffset.plotLeft;\n            y = p.y - gridOffset.plotTop;\n            gridX = Math.floor(x / scaledGridSize);\n            gridY = Math.floor(y / scaledGridSize);\n            key = gridY + ':' + gridX;\n            (_a = grid[key]) !== null && _a !== void 0 ? _a : (grid[key] = []);\n            grid[key].push({\n                dataIndex: dataIndexes[i],\n                x: dataX[i],\n                y: dataY[i]\n            });\n        }\n        return grid;\n    },\n    kmeans: function (dataX, dataY, dataIndexes, options) {\n        var series = this,\n            clusters = [],\n            noise = [],\n            group = {},\n            pointMaxDistance = options.processedDistance ||\n                clusterDefaults.layoutAlgorithm.distance,\n            iterations = options.iterations, \n            // Max pixel difference beetwen new and old cluster position.\n            maxClusterShift = 1;\n        var currentIteration = 0,\n            repeat = true,\n            pointX = 0,\n            pointY = 0,\n            tempPos,\n            pointClusterDistance = [];\n        options.processedGridSize = options.processedDistance;\n        // Use grid method to get groupedData object.\n        var groupedData = series.markerClusterAlgorithms ?\n                series.markerClusterAlgorithms.grid.call(series,\n            dataX,\n            dataY,\n            dataIndexes,\n            options) : {};\n        // Find clusters amount and its start positions\n        // based on grid grouped data.\n        for (var key in groupedData) {\n            if (groupedData[key].length > 1) {\n                tempPos = getClusterPosition(groupedData[key]);\n                clusters.push({\n                    posX: tempPos.x,\n                    posY: tempPos.y,\n                    oldX: 0,\n                    oldY: 0,\n                    startPointsLen: groupedData[key].length,\n                    points: []\n                });\n            }\n        }\n        // Start kmeans iteration process.\n        while (repeat) {\n            for (var _i = 0, clusters_1 = clusters; _i < clusters_1.length; _i++) {\n                var c = clusters_1[_i];\n                c.points.length = 0;\n            }\n            noise.length = 0;\n            for (var i = 0; i < dataX.length; i++) {\n                pointX = dataX[i];\n                pointY = dataY[i];\n                pointClusterDistance = series.getClusterDistancesFromPoint(clusters, pointX, pointY);\n                if (pointClusterDistance.length &&\n                    pointClusterDistance[0].distance < pointMaxDistance) {\n                    clusters[pointClusterDistance[0].clusterIndex].points.push({\n                        x: pointX,\n                        y: pointY,\n                        dataIndex: dataIndexes[i]\n                    });\n                }\n                else {\n                    noise.push({\n                        x: pointX,\n                        y: pointY,\n                        dataIndex: dataIndexes[i]\n                    });\n                }\n            }\n            // When cluster points array has only one point the\n            // point should be classified again.\n            for (var i = 0; i < clusters.length; i++) {\n                if (clusters[i].points.length === 1) {\n                    pointClusterDistance = series.getClusterDistancesFromPoint(clusters, clusters[i].points[0].x, clusters[i].points[0].y);\n                    if (pointClusterDistance[1].distance < pointMaxDistance) {\n                        // Add point to the next closest cluster.\n                        clusters[pointClusterDistance[1].clusterIndex].points\n                            .push(clusters[i].points[0]);\n                        // Clear points array.\n                        clusters[pointClusterDistance[0].clusterIndex]\n                            .points.length = 0;\n                    }\n                }\n            }\n            // Compute a new clusters position and check if it\n            // is different than the old one.\n            repeat = false;\n            for (var i = 0; i < clusters.length; i++) {\n                tempPos = getClusterPosition(clusters[i].points);\n                clusters[i].oldX = clusters[i].posX;\n                clusters[i].oldY = clusters[i].posY;\n                clusters[i].posX = tempPos.x;\n                clusters[i].posY = tempPos.y;\n                // Repeat the algorithm if at least one cluster\n                // is shifted more than maxClusterShift property.\n                if (clusters[i].posX > clusters[i].oldX + maxClusterShift ||\n                    clusters[i].posX < clusters[i].oldX - maxClusterShift ||\n                    clusters[i].posY > clusters[i].oldY + maxClusterShift ||\n                    clusters[i].posY < clusters[i].oldY - maxClusterShift) {\n                    repeat = true;\n                }\n            }\n            // If iterations property is set repeat the algorithm\n            // specified amount of times.\n            if (iterations) {\n                repeat = currentIteration < iterations - 1;\n            }\n            currentIteration++;\n        }\n        for (var i = 0, iEnd = clusters.length; i < iEnd; ++i) {\n            group['cluster' + i] = clusters[i].points;\n        }\n        for (var i = 0, iEnd = noise.length; i < iEnd; ++i) {\n            group['noise' + i] = [noise[i]];\n        }\n        return group;\n    },\n    optimizedKmeans: function (processedXData, processedYData, dataIndexes, options) {\n        var _a,\n            _b,\n            _c;\n        var series = this,\n            pointMaxDistance = options.processedDistance ||\n                clusterDefaults.layoutAlgorithm.gridSize,\n            extremes = series.getRealExtremes(),\n            clusterMarkerOptions = (series.options.cluster || {}).marker;\n        var distance,\n            group = {},\n            offset,\n            radius;\n        if (!series.markerClusterInfo || (series.initMaxX && series.initMaxX < extremes.maxX ||\n            series.initMinX && series.initMinX > extremes.minX ||\n            series.initMaxY && series.initMaxY < extremes.maxY ||\n            series.initMinY && series.initMinY > extremes.minY)) {\n            series.initMaxX = extremes.maxX;\n            series.initMinX = extremes.minX;\n            series.initMaxY = extremes.maxY;\n            series.initMinY = extremes.minY;\n            group = series.markerClusterAlgorithms ?\n                series.markerClusterAlgorithms.kmeans.call(series, processedXData, processedYData, dataIndexes, options) : {};\n            series.baseClusters = null;\n        }\n        else {\n            (_a = series.baseClusters) !== null && _a !== void 0 ? _a : (series.baseClusters = {\n                clusters: series.markerClusterInfo.clusters,\n                noise: series.markerClusterInfo.noise\n            });\n            for (var _i = 0, _d = series.baseClusters.clusters; _i < _d.length; _i++) {\n                var cluster = _d[_i];\n                cluster.pointsOutside = [];\n                cluster.pointsInside = [];\n                for (var _e = 0, _f = cluster.data; _e < _f.length; _e++) {\n                    var dataPoint = _f[_e];\n                    var dataPointPx = valuesToPixels(series,\n                        dataPoint),\n                        clusterPx = valuesToPixels(series,\n                        cluster);\n                    distance = Math.sqrt(Math.pow(dataPointPx.x - clusterPx.x, 2) +\n                        Math.pow(dataPointPx.y - clusterPx.y, 2));\n                    if ((_c = (_b = cluster.clusterZone) === null || _b === void 0 ? void 0 : _b.marker) === null || _c === void 0 ? void 0 : _c.radius) {\n                        radius = cluster.clusterZone.marker.radius;\n                    }\n                    else if (clusterMarkerOptions === null || clusterMarkerOptions === void 0 ? void 0 : clusterMarkerOptions.radius) {\n                        radius = clusterMarkerOptions.radius;\n                    }\n                    else {\n                        radius = clusterDefaults.marker.radius;\n                    }\n                    offset = pointMaxDistance - radius >= 0 ?\n                        pointMaxDistance - radius : radius;\n                    if (distance > radius + offset &&\n                        defined(cluster.pointsOutside)) {\n                        cluster.pointsOutside.push(dataPoint);\n                    }\n                    else if (defined(cluster.pointsInside)) {\n                        cluster.pointsInside.push(dataPoint);\n                    }\n                }\n                if (cluster.pointsInside.length) {\n                    group[cluster.id] = cluster.pointsInside;\n                }\n                var i = 0;\n                for (var _g = 0, _h = cluster.pointsOutside; _g < _h.length; _g++) {\n                    var p = _h[_g];\n                    group[cluster.id + '_noise' + i++] = [p];\n                }\n            }\n            for (var _j = 0, _k = series.baseClusters.noise; _j < _k.length; _j++) {\n                var noise = _k[_j];\n                group[noise.id] = noise.data;\n            }\n        }\n        return group;\n    }\n};\n/* *\n *\n *  Variables\n *\n * */\nvar baseGeneratePoints, \n/**\n * Points that ids are included in the oldPointsStateId array are hidden\n * before animation. Other ones are destroyed.\n * @private\n */\noldPointsStateId = [], stateIdCounter = 0;\n/* *\n *\n *  Functions\n *\n * */\n/** @private */\nfunction compose(highchartsDefaultOptions, ScatterSeriesClass) {\n    var scatterProto = ScatterSeriesClass.prototype;\n    if (!scatterProto.markerClusterAlgorithms) {\n        baseGeneratePoints = scatterProto.generatePoints;\n        scatterProto.markerClusterAlgorithms = markerClusterAlgorithms;\n        scatterProto.animateClusterPoint = seriesAnimateClusterPoint;\n        scatterProto.destroyClusteredData = seriesDestroyClusteredData;\n        scatterProto.generatePoints = seriesGeneratePoints;\n        scatterProto.getClusterDistancesFromPoint =\n            seriesGetClusterDistancesFromPoint;\n        scatterProto.getClusteredData = seriesGetClusteredData;\n        scatterProto.getGridOffset = seriesGetGridOffset;\n        scatterProto.getPointsState = seriesGetPointsState;\n        scatterProto.getRealExtremes = seriesGetRealExtremes;\n        scatterProto.getScaledGridSize = seriesGetScaledGridSize;\n        scatterProto.hideClusteredData = seriesHideClusteredData;\n        scatterProto.isValidGroupedDataObject = seriesIsValidGroupedDataObject;\n        scatterProto.preventClusterCollisions = seriesPreventClusterCollisions;\n        // Destroy grouped data on series destroy.\n        addEvent(ScatterSeriesClass, 'destroy', scatterProto.destroyClusteredData);\n        if (highchartsDefaultOptions.plotOptions) {\n            highchartsDefaultOptions.plotOptions.series = merge(highchartsDefaultOptions.plotOptions.series, MarkerClusters_MarkerClusterDefaults);\n        }\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction destroyOldPoints(oldState) {\n    var _a,\n        _b;\n    for (var _i = 0, _c = Object.keys(oldState); _i < _c.length; _i++) {\n        var key = _c[_i];\n        (_b = (_a = oldState[key].point) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInElement(elem, opacity, animation) {\n    elem.attr({ opacity: opacity }).animate({ opacity: 1 }, animation);\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, opacity) {\n    var _a,\n        _b;\n    // Fade in new point.\n    fadeInStatePoint(newPointObj, opacity, animation, true, true);\n    // Destroy old animated points.\n    for (var _i = 0, oldPoints_1 = oldPoints; _i < oldPoints_1.length; _i++) {\n        var p = oldPoints_1[_i];\n        (_b = (_a = p.point) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction fadeInStatePoint(stateObj, opacity, animation, fadeinGraphic, fadeinDataLabel) {\n    if (stateObj.point) {\n        if (fadeinGraphic && stateObj.point.graphic) {\n            stateObj.point.graphic.show();\n            fadeInElement(stateObj.point.graphic, opacity, animation);\n        }\n        if (fadeinDataLabel && stateObj.point.dataLabel) {\n            stateObj.point.dataLabel.show();\n            fadeInElement(stateObj.point.dataLabel, opacity, animation);\n        }\n    }\n}\n/**\n * Util function.\n * @private\n */\nfunction getClusterPosition(points) {\n    var pointsLen = points.length;\n    var sumX = 0,\n        sumY = 0;\n    for (var i = 0; i < pointsLen; i++) {\n        sumX += points[i].x;\n        sumY += points[i].y;\n    }\n    return {\n        x: sumX / pointsLen,\n        y: sumY / pointsLen\n    };\n}\n/**\n * Util function.Prepare array with sorted data objects to be compared in\n * getPointsState method.\n * @private\n */\nfunction getDataState(clusteredData, stateDataLen) {\n    var state = [];\n    state.length = stateDataLen;\n    clusteredData.clusters.forEach(function (cluster) {\n        cluster.data.forEach(function (elem) {\n            state[elem.dataIndex] = elem;\n        });\n    });\n    clusteredData.noise.forEach(function (noise) {\n        state[noise.data[0].dataIndex] = noise.data[0];\n    });\n    return state;\n}\n/**\n * Util function. Generate unique stateId for a state element.\n * @private\n */\nfunction getStateId() {\n    return Math.random().toString(36).substring(2, 7) + '-' + stateIdCounter++;\n}\n/**\n * Util function.\n * @private\n */\nfunction hideStatePoint(stateObj, hideGraphic, hideDataLabel) {\n    if (stateObj.point) {\n        if (hideGraphic && stateObj.point.graphic) {\n            stateObj.point.graphic.hide();\n        }\n        if (hideDataLabel && stateObj.point.dataLabel) {\n            stateObj.point.dataLabel.hide();\n        }\n    }\n}\n/** @private */\nfunction onPointDrillToCluster(event) {\n    var point = event.point || event.target;\n    point.firePointEvent('drillToCluster', event, function (e) {\n        var _a,\n            _b,\n            _c;\n        var _d;\n        var point = e.point || e.target,\n            series = point.series,\n            xAxis = series.xAxis,\n            yAxis = series.yAxis,\n            chart = series.chart,\n            inverted = chart.inverted,\n            mapView = chart.mapView,\n            pointer = chart.pointer,\n            drillToCluster = (_d = series.options.cluster) === null || _d === void 0 ? void 0 : _d.drillToCluster;\n        if (drillToCluster && point.clusteredData) {\n            var sortedDataX = point.clusteredData\n                    .map(function (data) { return data.x; })\n                    .sort(function (a,\n                b) { return a - b; }),\n                sortedDataY = point.clusteredData\n                    .map(function (data) { return data.y; })\n                    .sort(function (a,\n                b) { return a - b; }),\n                minX = sortedDataX[0],\n                maxX = sortedDataX[sortedDataX.length - 1],\n                minY = sortedDataY[0],\n                maxY = sortedDataY[sortedDataY.length - 1],\n                offsetX = Math.abs((maxX - minX) * 0.1),\n                offsetY = Math.abs((maxY - minY) * 0.1),\n                x1 = Math.min(minX,\n                maxX) - offsetX,\n                x2 = Math.max(minX,\n                maxX) + offsetX,\n                y1 = Math.min(minY,\n                maxY) - offsetY,\n                y2 = Math.max(minY,\n                maxY) + offsetY;\n            if (mapView) {\n                mapView.fitToBounds({ x1: x1, x2: x2, y1: y1, y2: y2 });\n            }\n            else if (xAxis && yAxis) {\n                var x1Px = xAxis.toPixels(x1),\n                    x2Px = xAxis.toPixels(x2),\n                    y1Px = yAxis.toPixels(y1),\n                    y2Px = yAxis.toPixels(y2);\n                if (inverted) {\n                    _a = [y1Px, y2Px, x1Px, x2Px], x1Px = _a[0], x2Px = _a[1], y1Px = _a[2], y2Px = _a[3];\n                }\n                if (x1Px > x2Px) {\n                    _b = [x2Px, x1Px], x1Px = _b[0], x2Px = _b[1];\n                }\n                if (y1Px > y2Px) {\n                    _c = [y2Px, y1Px], y1Px = _c[0], y2Px = _c[1];\n                }\n                if (pointer) {\n                    pointer.zoomX = true;\n                    pointer.zoomY = true;\n                }\n                chart.transform({\n                    from: {\n                        x: x1Px,\n                        y: y1Px,\n                        width: x2Px - x1Px,\n                        height: y2Px - y1Px\n                    }\n                });\n            }\n        }\n    });\n}\n/**\n * Util function.\n * @private\n */\nfunction pixelsToValues(series, pos) {\n    var chart = series.chart,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis;\n    if (chart.mapView) {\n        return chart.mapView.pixelsToProjectedUnits(pos);\n    }\n    return {\n        x: xAxis ? xAxis.toValue(pos.x) : 0,\n        y: yAxis ? yAxis.toValue(pos.y) : 0\n    };\n}\n/** @private */\nfunction seriesAnimateClusterPoint(clusterObj) {\n    var _a,\n        _b,\n        _c,\n        _d,\n        _e,\n        _f,\n        _g;\n    var series = this,\n        chart = series.chart,\n        mapView = chart.mapView,\n        animation = animObject((_a = series.options.cluster) === null || _a === void 0 ? void 0 : _a.animation),\n        animDuration = animation.duration || 500,\n        pointsState = (_b = series.markerClusterInfo) === null || _b === void 0 ? void 0 : _b.pointsState,\n        newState = pointsState === null || pointsState === void 0 ? void 0 : pointsState.newState,\n        oldState = pointsState === null || pointsState === void 0 ? void 0 : pointsState.oldState,\n        oldPoints = [];\n    var parentId,\n        oldPointObj,\n        newPointObj,\n        newPointBBox,\n        offset = 0,\n        newX = 0,\n        newY = 0,\n        isOldPointGrahic = false,\n        isCbHandled = false;\n    if (oldState && newState) {\n        newPointObj = newState[clusterObj.stateId];\n        var newPos = valuesToPixels(series,\n            newPointObj);\n        newX = newPos.x - (mapView ? 0 : chart.plotLeft);\n        newY = newPos.y - (mapView ? 0 : chart.plotTop);\n        // Point has one ancestor.\n        if (newPointObj.parentsId.length === 1) {\n            parentId = newState === null || newState === void 0 ? void 0 : newState[clusterObj.stateId].parentsId[0];\n            oldPointObj = oldState[parentId];\n            // If old and new positions are the same do not animate.\n            if (((_c = newPointObj.point) === null || _c === void 0 ? void 0 : _c.graphic) &&\n                ((_d = oldPointObj.point) === null || _d === void 0 ? void 0 : _d.plotX) &&\n                oldPointObj.point.plotY &&\n                (oldPointObj.point.plotX !== newPointObj.point.plotX ||\n                    oldPointObj.point.plotY !== newPointObj.point.plotY)) {\n                newPointBBox = newPointObj.point.graphic.getBBox();\n                // Marker image does not have the offset (#14342).\n                offset = ((_e = newPointObj.point.graphic) === null || _e === void 0 ? void 0 : _e.isImg) ?\n                    0 : newPointBBox.width / 2;\n                newPointObj.point.graphic.attr({\n                    x: oldPointObj.point.plotX - offset,\n                    y: oldPointObj.point.plotY - offset\n                });\n                newPointObj.point.graphic.animate({\n                    x: newX - (newPointObj.point.graphic.radius || 0),\n                    y: newY - (newPointObj.point.graphic.radius || 0)\n                }, animation, function () {\n                    var _a,\n                        _b;\n                    isCbHandled = true;\n                    // Destroy old point.\n                    (_b = (_a = oldPointObj.point) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a);\n                });\n                // Data label animation.\n                if (((_f = newPointObj.point.dataLabel) === null || _f === void 0 ? void 0 : _f.alignAttr) &&\n                    ((_g = oldPointObj.point.dataLabel) === null || _g === void 0 ? void 0 : _g.alignAttr)) {\n                    newPointObj.point.dataLabel.attr({\n                        x: oldPointObj.point.dataLabel.alignAttr.x,\n                        y: oldPointObj.point.dataLabel.alignAttr.y\n                    });\n                    newPointObj.point.dataLabel.animate({\n                        x: newPointObj.point.dataLabel.alignAttr.x,\n                        y: newPointObj.point.dataLabel.alignAttr.y\n                    }, animation);\n                }\n            }\n        }\n        else if (newPointObj.parentsId.length === 0) {\n            // Point has no ancestors - new point.\n            // Hide new point.\n            hideStatePoint(newPointObj, true, true);\n            syncTimeout(function () {\n                // Fade in new point.\n                fadeInStatePoint(newPointObj, 0.1, animation, true, true);\n            }, animDuration / 2);\n        }\n        else {\n            // Point has many ancestors.\n            // Hide new point before animation.\n            hideStatePoint(newPointObj, true, true);\n            newPointObj.parentsId.forEach(function (elem) {\n                var _a,\n                    _b,\n                    _c;\n                if (oldState === null || oldState === void 0 ? void 0 : oldState[elem]) {\n                    oldPointObj = oldState[elem];\n                    oldPoints.push(oldPointObj);\n                    if ((_a = oldPointObj.point) === null || _a === void 0 ? void 0 : _a.graphic) {\n                        isOldPointGrahic = true;\n                        oldPointObj.point.graphic.show();\n                        oldPointObj.point.graphic.animate({\n                            x: newX - (oldPointObj.point.graphic.radius || 0),\n                            y: newY - (oldPointObj.point.graphic.radius || 0),\n                            opacity: 0.4\n                        }, animation, function () {\n                            isCbHandled = true;\n                            fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.7);\n                        });\n                        if (oldPointObj.point.dataLabel &&\n                            oldPointObj.point.dataLabel.y !== -9999 &&\n                            ((_c = (_b = newPointObj.point) === null || _b === void 0 ? void 0 : _b.dataLabel) === null || _c === void 0 ? void 0 : _c.alignAttr)) {\n                            oldPointObj.point.dataLabel.show();\n                            oldPointObj.point.dataLabel.animate({\n                                x: newPointObj.point.dataLabel.alignAttr.x,\n                                y: newPointObj.point.dataLabel.alignAttr.y,\n                                opacity: 0.4\n                            }, animation);\n                        }\n                    }\n                }\n            });\n            // Make sure point is faded in.\n            syncTimeout(function () {\n                if (!isCbHandled) {\n                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.85);\n                }\n            }, animDuration);\n            if (!isOldPointGrahic) {\n                syncTimeout(function () {\n                    fadeInNewPointAndDestoryOld(newPointObj, oldPoints, animation, 0.1);\n                }, animDuration / 2);\n            }\n        }\n    }\n}\n/**\n * Destroy clustered data points.\n * @private\n */\nfunction seriesDestroyClusteredData() {\n    var _a;\n    // Clear previous groups.\n    (_a = this.markerClusterSeriesData) === null || _a === void 0 ? void 0 : _a.forEach(function (point) {\n        var _a;\n        (_a = point === null || point === void 0 ? void 0 : point.destroy) === null || _a === void 0 ? void 0 : _a.call(point);\n    });\n    this.markerClusterSeriesData = null;\n}\n/**\n * Override the generatePoints method by adding a reference to grouped data.\n * @private\n */\nfunction seriesGeneratePoints() {\n    var _a,\n        _b,\n        _c,\n        _d,\n        _e;\n    var series = this, chart = series.chart, mapView = chart.mapView, xData = series.getColumn('x'), yData = series.getColumn('y'), clusterOptions = series.options.cluster, realExtremes = series.getRealExtremes(), visibleXData = [], visibleYData = [], visibleDataIndexes = [];\n    var oldPointsState,\n        oldDataLen,\n        oldMarkerClusterInfo,\n        kmeansThreshold,\n        cropDataOffsetX,\n        cropDataOffsetY,\n        seriesMinX,\n        seriesMaxX,\n        seriesMinY,\n        seriesMaxY,\n        type,\n        algorithm,\n        clusteredData,\n        groupedData,\n        layoutAlgOptions,\n        point;\n    // For map point series, we need to resolve lon, lat and geometry options\n    // and project them on the plane in order to get x and y. In the regular\n    // series flow, this is not done until the `translate` method because the\n    // resulting [x, y] position depends on inset positions in the MapView.\n    if (mapView && series.is('mappoint') && xData && yData) {\n        (_a = series.options.data) === null || _a === void 0 ? void 0 : _a.forEach(function (p, i) {\n            var xy = series.projectPoint(p);\n            if (xy) {\n                xData[i] = xy.x;\n                yData[i] = xy.y;\n            }\n        });\n    }\n    if ((clusterOptions === null || clusterOptions === void 0 ? void 0 : clusterOptions.enabled) &&\n        (xData === null || xData === void 0 ? void 0 : xData.length) &&\n        (yData === null || yData === void 0 ? void 0 : yData.length) &&\n        !chart.polar) {\n        type = clusterOptions.layoutAlgorithm.type;\n        layoutAlgOptions = clusterOptions.layoutAlgorithm;\n        // Get processed algorithm properties.\n        layoutAlgOptions.processedGridSize = relativeLength(layoutAlgOptions.gridSize ||\n            clusterDefaults.layoutAlgorithm.gridSize, chart.plotWidth);\n        layoutAlgOptions.processedDistance = relativeLength(layoutAlgOptions.distance ||\n            clusterDefaults.layoutAlgorithm.distance, chart.plotWidth);\n        kmeansThreshold = layoutAlgOptions.kmeansThreshold ||\n            clusterDefaults.layoutAlgorithm.kmeansThreshold;\n        // Offset to prevent cluster size changes.\n        var halfGrid = layoutAlgOptions.processedGridSize / 2,\n            p1 = pixelsToValues(series, { x: 0,\n            y: 0 }),\n            p2 = pixelsToValues(series, { x: halfGrid,\n            y: halfGrid });\n        cropDataOffsetX = Math.abs(p1.x - p2.x);\n        cropDataOffsetY = Math.abs(p1.y - p2.y);\n        // Get only visible data.\n        for (var i = 0; i < xData.length; i++) {\n            if (!series.dataMaxX) {\n                if (!defined(seriesMaxX) ||\n                    !defined(seriesMinX) ||\n                    !defined(seriesMaxY) ||\n                    !defined(seriesMinY)) {\n                    seriesMaxX = seriesMinX = xData[i];\n                    seriesMaxY = seriesMinY = yData[i];\n                }\n                else if (isNumber(yData[i]) &&\n                    isNumber(seriesMaxY) &&\n                    isNumber(seriesMinY)) {\n                    seriesMaxX = Math.max(xData[i], seriesMaxX);\n                    seriesMinX = Math.min(xData[i], seriesMinX);\n                    seriesMaxY = Math.max(yData[i] || seriesMaxY, seriesMaxY);\n                    seriesMinY = Math.min(yData[i] || seriesMinY, seriesMinY);\n                }\n            }\n            // Crop data to visible ones with appropriate offset to prevent\n            // cluster size changes on the edge of the plot area.\n            if (xData[i] >= (realExtremes.minX - cropDataOffsetX) &&\n                xData[i] <= (realExtremes.maxX + cropDataOffsetX) &&\n                (yData[i] || realExtremes.minY) >=\n                    (realExtremes.minY - cropDataOffsetY) &&\n                (yData[i] || realExtremes.maxY) <=\n                    (realExtremes.maxY + cropDataOffsetY)) {\n                visibleXData.push(xData[i]);\n                visibleYData.push(yData[i]);\n                visibleDataIndexes.push(i);\n            }\n        }\n        // Save data max values.\n        if (defined(seriesMaxX) && defined(seriesMinX) &&\n            isNumber(seriesMaxY) && isNumber(seriesMinY)) {\n            series.dataMaxX = seriesMaxX;\n            series.dataMinX = seriesMinX;\n            series.dataMaxY = seriesMaxY;\n            series.dataMinY = seriesMinY;\n        }\n        if (isFunction(type)) {\n            algorithm = type;\n        }\n        else if (series.markerClusterAlgorithms) {\n            if (type && series.markerClusterAlgorithms[type]) {\n                algorithm = series.markerClusterAlgorithms[type];\n            }\n            else {\n                algorithm = visibleXData.length < kmeansThreshold ?\n                    series.markerClusterAlgorithms.kmeans :\n                    series.markerClusterAlgorithms.grid;\n            }\n        }\n        else {\n            algorithm = function () { return false; };\n        }\n        groupedData = algorithm.call(this, visibleXData, visibleYData, visibleDataIndexes, layoutAlgOptions);\n        clusteredData = groupedData ? series.getClusteredData(groupedData, clusterOptions) : groupedData;\n        // When animation is enabled get old points state.\n        if (clusterOptions.animation &&\n            ((_c = (_b = series.markerClusterInfo) === null || _b === void 0 ? void 0 : _b.pointsState) === null || _c === void 0 ? void 0 : _c.oldState)) {\n            // Destroy old points.\n            destroyOldPoints(series.markerClusterInfo.pointsState.oldState);\n            oldPointsState = series.markerClusterInfo.pointsState.newState;\n        }\n        else {\n            oldPointsState = {};\n        }\n        // Save points old state info.\n        oldDataLen = xData.length;\n        oldMarkerClusterInfo = series.markerClusterInfo;\n        if (clusteredData) {\n            series.dataTable.modified = new Data_DataTableCore({\n                columns: {\n                    x: clusteredData.groupedXData,\n                    y: clusteredData.groupedYData\n                }\n            });\n            series.hasGroupedData = true;\n            series.markerClusterInfo = clusteredData;\n            series.groupMap = clusteredData.groupMap;\n        }\n        baseGeneratePoints.apply(this);\n        if (clusteredData && series.markerClusterInfo) {\n            // Mark cluster points. Safe point reference in the cluster object.\n            (_d = series.markerClusterInfo.clusters) === null || _d === void 0 ? void 0 : _d.forEach(function (cluster) {\n                point = series.points[cluster.index];\n                point.isCluster = true;\n                point.clusteredData = cluster.data;\n                point.clusterPointsAmount = cluster.data.length;\n                cluster.point = point;\n                // Add zoom to cluster range.\n                addEvent(point, 'click', onPointDrillToCluster);\n            });\n            // Safe point reference in the noise object.\n            (_e = series.markerClusterInfo.noise) === null || _e === void 0 ? void 0 : _e.forEach(function (noise) {\n                noise.point = series.points[noise.index];\n            });\n            // When animation is enabled save points state.\n            if (clusterOptions.animation &&\n                series.markerClusterInfo) {\n                series.markerClusterInfo.pointsState = {\n                    oldState: oldPointsState,\n                    newState: series.getPointsState(clusteredData, oldMarkerClusterInfo, oldDataLen)\n                };\n            }\n            // Record grouped data in order to let it be destroyed the next time\n            // processData runs.\n            if (!clusterOptions.animation) {\n                this.destroyClusteredData();\n            }\n            else {\n                this.hideClusteredData();\n            }\n            this.markerClusterSeriesData =\n                this.hasGroupedData ? this.points : null;\n        }\n    }\n    else {\n        baseGeneratePoints.apply(this);\n    }\n}\n/** @private */\nfunction seriesGetClusterDistancesFromPoint(clusters, pointX, pointY) {\n    var pointClusterDistance = [];\n    for (var clusterIndex = 0; clusterIndex < clusters.length; clusterIndex++) {\n        var p1 = valuesToPixels(this, { x: pointX,\n            y: pointY }),\n            p2 = valuesToPixels(this, {\n                x: clusters[clusterIndex].posX,\n                y: clusters[clusterIndex].posY\n            }),\n            distance = Math.sqrt(Math.pow(p1.x - p2.x, 2) +\n                Math.pow(p1.y - p2.y, 2));\n        pointClusterDistance.push({ clusterIndex: clusterIndex, distance: distance });\n    }\n    return pointClusterDistance.sort(function (a, b) { return a.distance - b.distance; });\n}\n/** @private */\nfunction seriesGetClusteredData(groupedData, options) {\n    var series = this,\n        data = series.options.data,\n        groupedXData = [],\n        groupedYData = [],\n        clusters = [], // Container for clusters.\n        noise = [], // Container for points not belonging to any cluster.\n        groupMap = [], \n        // Prevent minimumClusterSize lower than 2.\n        minimumClusterSize = Math.max(2,\n        options.minimumClusterSize || 2);\n    var index = 0,\n        stateId,\n        point,\n        points,\n        pointUserOptions,\n        pointsLen,\n        marker,\n        clusterPos,\n        pointOptions,\n        clusterTempPos,\n        zoneOptions,\n        clusterZone,\n        clusterZoneClassName;\n    // Check if groupedData is valid when user uses a custom algorithm.\n    if (isFunction(options.layoutAlgorithm.type) &&\n        !series.isValidGroupedDataObject(groupedData)) {\n        error('Highcharts marker-clusters module: ' +\n            'The custom algorithm result is not valid!', false, series.chart);\n        return false;\n    }\n    for (var k in groupedData) {\n        if (groupedData[k].length >= minimumClusterSize) {\n            points = groupedData[k];\n            stateId = getStateId();\n            pointsLen = points.length;\n            // Get zone options for cluster.\n            if (options.zones) {\n                for (var i = 0; i < options.zones.length; i++) {\n                    if (pointsLen >= options.zones[i].from &&\n                        pointsLen <= options.zones[i].to) {\n                        clusterZone = options.zones[i];\n                        clusterZone.zoneIndex = i;\n                        zoneOptions = options.zones[i].marker;\n                        clusterZoneClassName = options.zones[i].className;\n                    }\n                }\n            }\n            clusterTempPos = getClusterPosition(points);\n            if (options.layoutAlgorithm.type === 'grid' &&\n                !options.allowOverlap) {\n                marker = series.options.marker || {};\n                clusterPos = series.preventClusterCollisions({\n                    x: clusterTempPos.x,\n                    y: clusterTempPos.y,\n                    key: k,\n                    groupedData: groupedData,\n                    gridSize: series.getScaledGridSize(options.layoutAlgorithm),\n                    defaultRadius: marker.radius || 3 + (marker.lineWidth || 0),\n                    clusterRadius: (zoneOptions && zoneOptions.radius) ?\n                        zoneOptions.radius :\n                        (options.marker || {}).radius ||\n                            clusterDefaults.marker.radius\n                });\n            }\n            else {\n                clusterPos = {\n                    x: clusterTempPos.x,\n                    y: clusterTempPos.y\n                };\n            }\n            for (var i = 0; i < pointsLen; i++) {\n                points[i].parentStateId = stateId;\n            }\n            clusters.push({\n                x: clusterPos.x,\n                y: clusterPos.y,\n                id: k,\n                stateId: stateId,\n                index: index,\n                data: points,\n                clusterZone: clusterZone,\n                clusterZoneClassName: clusterZoneClassName\n            });\n            groupedXData.push(clusterPos.x);\n            groupedYData.push(clusterPos.y);\n            groupMap.push({\n                options: {\n                    formatPrefix: 'cluster',\n                    dataLabels: options.dataLabels,\n                    marker: merge(options.marker, {\n                        states: options.states\n                    }, zoneOptions || {})\n                }\n            });\n            // Save cluster data points options.\n            if (data === null || data === void 0 ? void 0 : data.length) {\n                for (var i = 0; i < pointsLen; i++) {\n                    if (isObject(data[points[i].dataIndex])) {\n                        points[i].options = data[points[i].dataIndex];\n                    }\n                }\n            }\n            index++;\n            zoneOptions = null;\n        }\n        else {\n            for (var i = 0; i < groupedData[k].length; i++) {\n                // Points not belonging to any cluster.\n                point = groupedData[k][i];\n                stateId = getStateId();\n                pointOptions = null;\n                pointUserOptions = data === null || data === void 0 ? void 0 : data[point.dataIndex];\n                groupedXData.push(point.x);\n                groupedYData.push(point.y);\n                point.parentStateId = stateId;\n                noise.push({\n                    x: point.x,\n                    y: point.y,\n                    id: k,\n                    stateId: stateId,\n                    index: index,\n                    data: groupedData[k]\n                });\n                if (pointUserOptions &&\n                    typeof pointUserOptions === 'object' &&\n                    !isArray(pointUserOptions)) {\n                    pointOptions = merge(pointUserOptions, { x: point.x, y: point.y });\n                }\n                else {\n                    pointOptions = {\n                        userOptions: pointUserOptions,\n                        x: point.x,\n                        y: point.y\n                    };\n                }\n                groupMap.push({ options: pointOptions });\n                index++;\n            }\n        }\n    }\n    return {\n        clusters: clusters,\n        noise: noise,\n        groupedXData: groupedXData,\n        groupedYData: groupedYData,\n        groupMap: groupMap\n    };\n}\n/** @private */\nfunction seriesGetGridOffset() {\n    var series = this,\n        chart = series.chart,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis;\n    var plotLeft = 0,\n        plotTop = 0;\n    if (xAxis && series.dataMinX && series.dataMaxX) {\n        plotLeft = xAxis.reversed ?\n            xAxis.toPixels(series.dataMaxX) : xAxis.toPixels(series.dataMinX);\n    }\n    else {\n        plotLeft = chart.plotLeft;\n    }\n    if (yAxis && series.dataMinY && series.dataMaxY) {\n        plotTop = yAxis.reversed ?\n            yAxis.toPixels(series.dataMinY) : yAxis.toPixels(series.dataMaxY);\n    }\n    else {\n        plotTop = chart.plotTop;\n    }\n    return { plotLeft: plotLeft, plotTop: plotTop };\n}\n/**\n * Point state used when animation is enabled to compare and bind old points\n * with new ones.\n * @private\n */\nfunction seriesGetPointsState(clusteredData, oldMarkerClusterInfo, dataLength) {\n    var _a;\n    var oldDataStateArr = oldMarkerClusterInfo ?\n            getDataState(oldMarkerClusterInfo,\n        dataLength) : [],\n        newDataStateArr = getDataState(clusteredData,\n        dataLength),\n        state = {};\n    // Clear global array before populate with new ids.\n    oldPointsStateId = [];\n    // Build points state structure.\n    clusteredData.clusters.forEach(function (cluster) {\n        state[cluster.stateId] = {\n            x: cluster.x,\n            y: cluster.y,\n            id: cluster.stateId,\n            point: cluster.point,\n            parentsId: []\n        };\n    });\n    clusteredData.noise.forEach(function (noise) {\n        state[noise.stateId] = {\n            x: noise.x,\n            y: noise.y,\n            id: noise.stateId,\n            point: noise.point,\n            parentsId: []\n        };\n    });\n    var newState,\n        oldState;\n    // Bind new and old state.\n    for (var i = 0; i < newDataStateArr.length; i++) {\n        newState = newDataStateArr[i];\n        oldState = oldDataStateArr[i];\n        if ((newState === null || newState === void 0 ? void 0 : newState.parentStateId) &&\n            (oldState === null || oldState === void 0 ? void 0 : oldState.parentStateId) &&\n            ((_a = state[newState.parentStateId]) === null || _a === void 0 ? void 0 : _a.parentsId.indexOf(oldState.parentStateId)) === -1) {\n            state[newState.parentStateId].parentsId.push(oldState.parentStateId);\n            if (oldPointsStateId.indexOf(oldState.parentStateId) === -1) {\n                oldPointsStateId.push(oldState.parentStateId);\n            }\n        }\n    }\n    return state;\n}\n/** @private */\nfunction seriesGetRealExtremes() {\n    var chart = this.chart,\n        x = chart.mapView ? 0 : chart.plotLeft,\n        y = chart.mapView ? 0 : chart.plotTop,\n        p1 = pixelsToValues(this, {\n            x: x,\n            y: y\n        }),\n        p2 = pixelsToValues(this, {\n            x: x + chart.plotWidth,\n            y: x + chart.plotHeight\n        }),\n        realMinX = p1.x,\n        realMaxX = p2.x,\n        realMinY = p1.y,\n        realMaxY = p2.y;\n    return {\n        minX: Math.min(realMinX, realMaxX),\n        maxX: Math.max(realMinX, realMaxX),\n        minY: Math.min(realMinY, realMaxY),\n        maxY: Math.max(realMinY, realMaxY)\n    };\n}\n/** @private */\nfunction seriesGetScaledGridSize(options) {\n    var series = this,\n        xAxis = series.xAxis,\n        mapView = series.chart.mapView,\n        processedGridSize = options.processedGridSize ||\n            clusterDefaults.layoutAlgorithm.gridSize;\n    var search = true,\n        k = 1,\n        divider = 1;\n    if (!series.gridValueSize) {\n        if (mapView) {\n            series.gridValueSize = processedGridSize / mapView.getScale();\n        }\n        else {\n            series.gridValueSize = Math.abs(xAxis.toValue(processedGridSize) - xAxis.toValue(0));\n        }\n    }\n    var gridSize = mapView ?\n            series.gridValueSize * mapView.getScale() :\n            xAxis.toPixels(series.gridValueSize) - xAxis.toPixels(0);\n    var scale = +(processedGridSize / gridSize).toFixed(14);\n    // Find the level and its divider.\n    while (search && scale !== 1) {\n        var level = Math.pow(2,\n            k);\n        if (scale > 0.75 && scale < 1.25) {\n            search = false;\n        }\n        else if (scale >= (1 / level) && scale < 2 * (1 / level)) {\n            search = false;\n            divider = level;\n        }\n        else if (scale <= level && scale > level / 2) {\n            search = false;\n            divider = 1 / level;\n        }\n        k++;\n    }\n    return (processedGridSize / divider) / scale;\n}\n/**\n * Hide clustered data points.\n * @private\n */\nfunction seriesHideClusteredData() {\n    var _a,\n        _b;\n    var clusteredSeriesData = this.markerClusterSeriesData,\n        oldState = (_b = (_a = this.markerClusterInfo) === null || _a === void 0 ? void 0 : _a.pointsState) === null || _b === void 0 ? void 0 : _b.oldState,\n        oldPointsId = oldPointsStateId.map(function (elem) { var _a; return ((_a = oldState === null || oldState === void 0 ? void 0 : oldState[elem].point) === null || _a === void 0 ? void 0 : _a.id) || ''; });\n    clusteredSeriesData === null || clusteredSeriesData === void 0 ? void 0 : clusteredSeriesData.forEach(function (point) {\n        var _a;\n        // If an old point is used in animation hide it, otherwise destroy.\n        if (point &&\n            oldPointsId.indexOf(point.id) !== -1) {\n            if (point.graphic) {\n                point.graphic.hide();\n            }\n            if (point.dataLabel) {\n                point.dataLabel.hide();\n            }\n        }\n        else {\n            (_a = point === null || point === void 0 ? void 0 : point.destroy) === null || _a === void 0 ? void 0 : _a.call(point);\n        }\n    });\n}\n/**\n * Check if user algorithm result is valid groupedDataObject.\n * @private\n */\nfunction seriesIsValidGroupedDataObject(groupedData) {\n    var result = false;\n    if (!isObject(groupedData)) {\n        return false;\n    }\n    MarkerClusterScatter_objectEach(groupedData, function (elem) {\n        result = true;\n        if (!isArray(elem) || !elem.length) {\n            result = false;\n            return;\n        }\n        for (var i = 0; i < elem.length; i++) {\n            if (!isObject(elem[i]) || (!elem[i].x || !elem[i].y)) {\n                result = false;\n                return;\n            }\n        }\n    });\n    return result;\n}\n/** @private */\nfunction seriesPreventClusterCollisions(props) {\n    var _a;\n    var _b,\n        _c,\n        _d;\n    var series = this,\n        _e = props.key.split(':').map(parseFloat),\n        gridY = _e[0],\n        gridX = _e[1],\n        gridSize = props.gridSize,\n        groupedData = props.groupedData,\n        defaultRadius = props.defaultRadius,\n        clusterRadius = props.clusterRadius,\n        gridXPx = gridX * gridSize,\n        gridYPx = gridY * gridSize,\n        propsPx = valuesToPixels(series,\n        props),\n        gridsToCheckCollision = [],\n        clusterMarkerOptions = (_b = series.options.cluster) === null || _b === void 0 ? void 0 : _b.marker,\n        zoneOptions = (_c = series.options.cluster) === null || _c === void 0 ? void 0 : _c.zones,\n        gridOffset = series.getGridOffset();\n    var xPixel = propsPx.x,\n        yPixel = propsPx.y,\n        pointsLen = 0,\n        radius = 0,\n        nextXPixel,\n        nextYPixel,\n        signX,\n        signY,\n        cornerGridX,\n        cornerGridY,\n        j,\n        itemX,\n        itemY,\n        nextClusterPos,\n        maxDist,\n        keys;\n    // Distance to the grid start.\n    xPixel -= gridOffset.plotLeft;\n    yPixel -= gridOffset.plotTop;\n    for (var i = 1; i < 5; i++) {\n        signX = i % 2 ? -1 : 1;\n        signY = i < 3 ? -1 : 1;\n        cornerGridX = Math.floor((xPixel + signX * clusterRadius) / gridSize);\n        cornerGridY = Math.floor((yPixel + signY * clusterRadius) / gridSize);\n        keys = [\n            cornerGridY + ':' + cornerGridX,\n            cornerGridY + ':' + gridX,\n            gridY + ':' + cornerGridX\n        ];\n        for (j = 0; j < keys.length; j++) {\n            if (gridsToCheckCollision.indexOf(keys[j]) === -1 &&\n                keys[j] !== props.key) {\n                gridsToCheckCollision.push(keys[j]);\n            }\n        }\n    }\n    for (var _i = 0, gridsToCheckCollision_1 = gridsToCheckCollision; _i < gridsToCheckCollision_1.length; _i++) {\n        var item = gridsToCheckCollision_1[_i];\n        if (groupedData[item]) {\n            // Cluster or noise position is already computed.\n            if (!groupedData[item].posX) {\n                nextClusterPos = getClusterPosition(groupedData[item]);\n                groupedData[item].posX = nextClusterPos.x;\n                groupedData[item].posY = nextClusterPos.y;\n            }\n            var pos_1 = valuesToPixels(series, {\n                    x: groupedData[item].posX || 0,\n                    y: groupedData[item].posY || 0\n                });\n            nextXPixel = pos_1.x - gridOffset.plotLeft;\n            nextYPixel = pos_1.y - gridOffset.plotTop;\n            _a = item.split(':').map(parseFloat), itemY = _a[0], itemX = _a[1];\n            if (zoneOptions) {\n                pointsLen = groupedData[item].length;\n                for (var i = 0; i < zoneOptions.length; i++) {\n                    if (pointsLen >= zoneOptions[i].from &&\n                        pointsLen <= zoneOptions[i].to) {\n                        if (defined((_d = zoneOptions[i].marker) === null || _d === void 0 ? void 0 : _d.radius)) {\n                            radius = zoneOptions[i].marker.radius || 0;\n                        }\n                        else if (clusterMarkerOptions === null || clusterMarkerOptions === void 0 ? void 0 : clusterMarkerOptions.radius) {\n                            radius = clusterMarkerOptions.radius;\n                        }\n                        else {\n                            radius = clusterDefaults.marker.radius;\n                        }\n                    }\n                }\n            }\n            if (groupedData[item].length > 1 &&\n                radius === 0 &&\n                (clusterMarkerOptions === null || clusterMarkerOptions === void 0 ? void 0 : clusterMarkerOptions.radius)) {\n                radius = clusterMarkerOptions.radius;\n            }\n            else if (groupedData[item].length === 1) {\n                radius = defaultRadius;\n            }\n            maxDist = clusterRadius + radius;\n            radius = 0;\n            if (itemX !== gridX &&\n                Math.abs(xPixel - nextXPixel) < maxDist) {\n                xPixel = itemX - gridX < 0 ? gridXPx + clusterRadius :\n                    gridXPx + gridSize - clusterRadius;\n            }\n            if (itemY !== gridY &&\n                Math.abs(yPixel - nextYPixel) < maxDist) {\n                yPixel = itemY - gridY < 0 ? gridYPx + clusterRadius :\n                    gridYPx + gridSize - clusterRadius;\n            }\n        }\n    }\n    var pos = pixelsToValues(series, {\n            x: xPixel + gridOffset.plotLeft,\n            y: yPixel + gridOffset.plotTop\n        });\n    groupedData[props.key].posX = pos.x;\n    groupedData[props.key].posY = pos.y;\n    return pos;\n}\n/**\n * Util function.\n * @private\n */\nfunction valuesToPixels(series, pos) {\n    var chart = series.chart,\n        xAxis = series.xAxis,\n        yAxis = series.yAxis;\n    if (chart.mapView) {\n        return chart.mapView.projectedUnitsToPixels(pos);\n    }\n    return {\n        x: xAxis ? xAxis.toPixels(pos.x) : 0,\n        y: yAxis ? yAxis.toPixels(pos.y) : 0\n    };\n}\n/* *\n *\n *  Default Export\n *\n * */\nvar MarkerClusterScatter = {\n    compose: compose\n};\n/* harmony default export */ var MarkerClusters_MarkerClusterScatter = (MarkerClusterScatter);\n\n;// ./code/es5/es-modules/Extensions/MarkerClusters/MarkerClusters.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2025 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n\nvar MarkerClusters_animObject = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).animObject;\n\nvar defaultOptions = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).defaultOptions;\n\nvar composed = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).composed;\n\n\n\nvar MarkerClusters_addEvent = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).addEvent, MarkerClusters_defined = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).defined, MarkerClusters_error = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).error, MarkerClusters_isFunction = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).isFunction, MarkerClusters_merge = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).merge, pushUnique = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).pushUnique, MarkerClusters_syncTimeout = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()).syncTimeout;\n/* *\n *\n *  Constants\n *\n * */\n(defaultOptions.plotOptions || {}).series = MarkerClusters_merge((defaultOptions.plotOptions || {}).series, MarkerClusters_MarkerClusterDefaults);\n/* *\n *\n *  Functions\n *\n * */\n/** @private */\nfunction MarkerClusters_compose(AxisClass, ChartClass, highchartsDefaultOptions, SeriesClass) {\n    if (pushUnique(composed, 'MarkerClusters')) {\n        var PointClass = SeriesClass.prototype.pointClass,\n            ScatterSeries = SeriesClass.types.scatter;\n        MarkerClusters_addEvent(AxisClass, 'setExtremes', onAxisSetExtremes);\n        MarkerClusters_addEvent(ChartClass, 'render', onChartRender);\n        MarkerClusters_addEvent(PointClass, 'drillToCluster', MarkerClusters_onPointDrillToCluster);\n        MarkerClusters_addEvent(PointClass, 'update', onPointUpdate);\n        MarkerClusters_addEvent(SeriesClass, 'afterRender', onSeriesAfterRender);\n        if (ScatterSeries) {\n            MarkerClusters_MarkerClusterScatter\n                .compose(highchartsDefaultOptions, ScatterSeries);\n        }\n    }\n}\n/**\n * Destroy the old tooltip after zoom.\n * @private\n */\nfunction onAxisSetExtremes() {\n    var chart = this.chart;\n    var animationDuration = 0;\n    for (var _i = 0, _a = chart.series; _i < _a.length; _i++) {\n        var series = _a[_i];\n        if (series.markerClusterInfo) {\n            animationDuration = (MarkerClusters_animObject((series.options.cluster || {}).animation).duration ||\n                0);\n        }\n    }\n    MarkerClusters_syncTimeout(function () {\n        if (chart.tooltip) {\n            chart.tooltip.destroy();\n        }\n    }, animationDuration);\n}\n/**\n * Handle animation.\n * @private\n */\nfunction onChartRender() {\n    var _a;\n    var chart = this;\n    for (var _i = 0, _b = (chart.series || []); _i < _b.length; _i++) {\n        var series = _b[_i];\n        if (series.markerClusterInfo) {\n            var options = series.options.cluster,\n                pointsState = (series.markerClusterInfo || {}).pointsState,\n                oldState = (pointsState || {}).oldState;\n            if ((options || {}).animation &&\n                series.markerClusterInfo &&\n                (((_a = series.chart.pointer) === null || _a === void 0 ? void 0 : _a.pinchDown) || []).length === 0 &&\n                ((series.xAxis || {}).eventArgs || {}).trigger !== 'pan' &&\n                oldState &&\n                Object.keys(oldState).length) {\n                for (var _c = 0, _d = series.markerClusterInfo.clusters; _c < _d.length; _c++) {\n                    var cluster = _d[_c];\n                    series.animateClusterPoint(cluster);\n                }\n                for (var _e = 0, _f = series.markerClusterInfo.noise; _e < _f.length; _e++) {\n                    var noise = _f[_e];\n                    series.animateClusterPoint(noise);\n                }\n            }\n        }\n    }\n}\n/** @private */\nfunction MarkerClusters_onPointDrillToCluster(event) {\n    var point = event.point || event.target,\n        series = point.series,\n        clusterOptions = series.options.cluster,\n        onDrillToCluster = ((clusterOptions || {}).events || {}).drillToCluster;\n    if (MarkerClusters_isFunction(onDrillToCluster)) {\n        onDrillToCluster.call(this, event);\n    }\n}\n/**\n * Override point prototype to throw a warning when trying to update\n * clustered point.\n * @private\n */\nfunction onPointUpdate() {\n    var point = this;\n    if (point.dataGroup) {\n        MarkerClusters_error('Highcharts marker-clusters module: ' +\n            'Running `Point.update` when point belongs to clustered series' +\n            ' is not supported.', false, point.series.chart);\n        return false;\n    }\n}\n/**\n * Add classes, change mouse cursor.\n * @private\n */\nfunction onSeriesAfterRender() {\n    var series = this,\n        clusterZoomEnabled = (series.options.cluster || {}).drillToCluster;\n    if (series.markerClusterInfo && series.markerClusterInfo.clusters) {\n        for (var _i = 0, _a = series.markerClusterInfo.clusters; _i < _a.length; _i++) {\n            var cluster = _a[_i];\n            if (cluster.point && cluster.point.graphic) {\n                cluster.point.graphic.addClass('highcharts-cluster-point');\n                // Change cursor to pointer when drillToCluster is enabled.\n                if (clusterZoomEnabled && cluster.point) {\n                    cluster.point.graphic.css({\n                        cursor: 'pointer'\n                    });\n                    if (cluster.point.dataLabel) {\n                        cluster.point.dataLabel.css({\n                            cursor: 'pointer'\n                        });\n                    }\n                }\n                if (MarkerClusters_defined(cluster.clusterZone)) {\n                    cluster.point.graphic.addClass(cluster.clusterZoneClassName ||\n                        'highcharts-cluster-zone-' +\n                            cluster.clusterZone.zoneIndex);\n                }\n            }\n        }\n    }\n}\n/* *\n *\n *  Default Export\n *\n * */\nvar MarkerClusters = {\n    compose: MarkerClusters_compose\n};\n/* harmony default export */ var MarkerClusters_MarkerClusters = (MarkerClusters);\n/* *\n *\n *  API Options\n *\n * */\n/**\n * Function callback when a cluster is clicked.\n *\n * @callback Highcharts.MarkerClusterDrillCallbackFunction\n *\n * @param {Highcharts.Point} this\n *        The point where the event occurred.\n *\n * @param {Highcharts.PointClickEventObject} event\n *        Event arguments.\n */\n''; // Keeps doclets above in JS file\n\n;// ./code/es5/es-modules/Extensions/MarkerClusters/MarkerClusterSymbols.js\n/* *\n *\n *  Marker clusters module.\n *\n *  (c) 2010-2025 Torstein Honsi\n *\n *  Author: Wojciech Chmiel\n *\n *  License: www.highcharts.com/license\n *\n *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n *\n * */\n\n/* *\n *\n *  Variables\n *\n * */\nvar symbols;\n/* *\n *\n *  Functions\n *\n * */\n/**\n * Cluster symbol.\n * @private\n */\nfunction MarkerClusterSymbols_cluster(x, y, width, height) {\n    var w = width / 2, h = height / 2, outerWidth = 1, space = 1, inner = symbols.arc(x + w, y + h, w - space * 4, h - space * 4, {\n            start: Math.PI * 0.5,\n            end: Math.PI * 2.5,\n            open: false\n        }), outer1 = symbols.arc(x + w, y + h, w - space * 3, h - space * 3, {\n            start: Math.PI * 0.5,\n            end: Math.PI * 2.5,\n            innerR: w - outerWidth * 2,\n            open: false\n        }), outer2 = symbols.arc(x + w, y + h, w - space, h - space, {\n            start: Math.PI * 0.5,\n            end: Math.PI * 2.5,\n            innerR: w,\n            open: false\n        });\n    return outer2.concat(outer1, inner);\n}\n/**\n * @private\n */\nfunction MarkerClusterSymbols_compose(SVGRendererClass) {\n    symbols = SVGRendererClass.prototype.symbols;\n    symbols.cluster = MarkerClusterSymbols_cluster;\n}\n/* *\n *\n *  Default Export\n *\n * */\nvar MarkerClusterSymbols = {\n    compose: MarkerClusterSymbols_compose\n};\n/* harmony default export */ var MarkerClusters_MarkerClusterSymbols = (MarkerClusterSymbols);\n\n;// ./code/es5/es-modules/masters/modules/marker-clusters.js\n\n\n\n\n\nvar G = (highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default());\nMarkerClusters_MarkerClusters.compose(G.Axis, G.Chart, G.defaultOptions, G.Series);\nMarkerClusters_MarkerClusterSymbols.compose(G.SVGRenderer);\n/* harmony default export */ var marker_clusters_src = ((highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default()));\n\n__webpack_exports__ = __webpack_exports__[\"default\"];\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});"],"names":["root","factory","exports","module","require","define","amd","__WEBPACK_EXTERNAL_MODULE__944__","symbols","__webpack_modules__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","__webpack_exports__","marker_clusters_src","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_","highcharts_commonjs_highcharts_commonjs2_highcharts_root_Highcharts_default","MarkerClusters_MarkerClusterDefaults","cluster","enabled","allowOverlap","animation","duration","drillToCluster","minimumClusterSize","layoutAlgorithm","gridSize","distance","kmeansThreshold","marker","symbol","radius","lineWidth","lineColor","dataLabels","format","verticalAlign","align","style","color","inside","tooltip","clusterFormat","__spreadArray","to","from","pack","arguments","length","ar","i","l","Array","slice","concat","ColumnUtils","setLength","column","asSubarray","isArray","splice","start","deleteCount","removedAsSubarray","items","removed","apply","array","Constructor","getPrototypeOf","constructor","result","set","subarray","baseGeneratePoints","Data_ColumnUtils","fireEvent","objectEach","uniqueKey","DataTableCore","options","_this","autoId","id","columns","modified","rowCount","versionTag","columnName","Math","max","applyRowCount","deleteRows","rowIndex","length_1","getColumn","asReference","getColumns","columnNames","keys","reduce","getRow","map","_a","setColumn","eventDetail","setColumns","silent","setRow","row","insert","indexRowCount","cellValue","addColumns","animObject","clusterDefaults","addEvent","defined","error","isFunction","isObject","isNumber","merge","MarkerClusterScatter_objectEach","relativeLength","syncTimeout","markerClusterAlgorithms","grid","dataX","dataY","dataIndexes","x","y","gridX","gridOffset","series","getGridOffset","scaledGridSize","getScaledGridSize","p","valuesToPixels","plotLeft","plotTop","floor","gridY","push","dataIndex","kmeans","tempPos","clusters","noise","group","pointMaxDistance","processedDistance","iterations","currentIteration","repeat","pointX","pointY","pointClusterDistance","processedGridSize","groupedData","getClusterPosition","posX","posY","oldX","oldY","startPointsLen","points","_i","clusters_1","c","getClusterDistancesFromPoint","clusterIndex","iEnd","optimizedKmeans","processedXData","processedYData","_b","_c","offset","extremes","getRealExtremes","clusterMarkerOptions","markerClusterInfo","initMaxX","maxX","initMinX","minX","initMaxY","maxY","initMinY","minY","baseClusters","_d","pointsOutside","pointsInside","_e","_f","data","dataPoint","dataPointPx","clusterPx","sqrt","pow","clusterZone","_g","_h","_j","_k","oldPointsStateId","stateIdCounter","fadeInElement","elem","opacity","attr","animate","fadeInNewPointAndDestoryOld","newPointObj","oldPoints","fadeInStatePoint","oldPoints_1","point","destroy","stateObj","fadeinGraphic","fadeinDataLabel","graphic","show","dataLabel","pointsLen","sumX","sumY","getDataState","clusteredData","stateDataLen","state","forEach","getStateId","random","toString","substring","hideStatePoint","hideGraphic","hideDataLabel","hide","onPointDrillToCluster","event","target","firePointEvent","e","xAxis","yAxis","chart","inverted","mapView","pointer","sortedDataX","sort","b","sortedDataY","offsetX","abs","offsetY","x1","min","x2","y1","y2","fitToBounds","x1Px","toPixels","x2Px","y1Px","y2Px","zoomX","zoomY","transform","width","height","pixelsToValues","pos","pixelsToProjectedUnits","toValue","seriesAnimateClusterPoint","clusterObj","oldPointObj","newPointBBox","animDuration","pointsState","newState","oldState","newX","newY","isOldPointGrahic","isCbHandled","newPos","stateId","parentsId","plotX","plotY","getBBox","isImg","alignAttr","seriesDestroyClusteredData","markerClusterSeriesData","seriesGeneratePoints","oldPointsState","oldDataLen","oldMarkerClusterInfo","cropDataOffsetX","cropDataOffsetY","seriesMinX","seriesMaxX","seriesMinY","seriesMaxY","type","algorithm","layoutAlgOptions","xData","yData","clusterOptions","realExtremes","visibleXData","visibleYData","visibleDataIndexes","is","xy","projectPoint","polar","plotWidth","halfGrid","p1","p2","dataMaxX","dataMinX","dataMaxY","dataMinY","getClusteredData","destroyOldPoints","dataTable","groupedXData","groupedYData","hasGroupedData","groupMap","index","isCluster","clusterPointsAmount","getPointsState","hideClusteredData","destroyClusteredData","seriesGetClusterDistancesFromPoint","seriesGetClusteredData","pointUserOptions","clusterPos","pointOptions","clusterTempPos","zoneOptions","clusterZoneClassName","isValidGroupedDataObject","k","zones","zoneIndex","className","preventClusterCollisions","defaultRadius","clusterRadius","parentStateId","formatPrefix","states","userOptions","seriesGetGridOffset","reversed","seriesGetPointsState","dataLength","oldDataStateArr","newDataStateArr","indexOf","seriesGetRealExtremes","plotHeight","realMinX","realMaxX","realMinY","realMaxY","seriesGetScaledGridSize","search","divider","gridValueSize","getScale","scale","toFixed","level","seriesHideClusteredData","clusteredSeriesData","oldPointsId","seriesIsValidGroupedDataObject","seriesPreventClusterCollisions","props","nextXPixel","nextYPixel","signX","signY","cornerGridX","cornerGridY","j","itemX","itemY","nextClusterPos","maxDist","split","parseFloat","gridXPx","gridYPx","propsPx","gridsToCheckCollision","xPixel","yPixel","gridsToCheckCollision_1","item","pos_1","projectedUnitsToPixels","MarkerClusters_MarkerClusterScatter","compose","highchartsDefaultOptions","ScatterSeriesClass","scatterProto","generatePoints","animateClusterPoint","plotOptions","MarkerClusters_animObject","defaultOptions","composed","MarkerClusters_addEvent","MarkerClusters_defined","MarkerClusters_error","MarkerClusters_isFunction","MarkerClusters_merge","pushUnique","MarkerClusters_syncTimeout","onAxisSetExtremes","animationDuration","onChartRender","pinchDown","eventArgs","trigger","MarkerClusters_onPointDrillToCluster","onDrillToCluster","events","onPointUpdate","dataGroup","onSeriesAfterRender","clusterZoomEnabled","addClass","css","cursor","MarkerClusterSymbols_cluster","w","h","inner","arc","space","PI","end","open","outer1","innerR","outerWidth","outer2","G","MarkerClusters_MarkerClusters","AxisClass","ChartClass","SeriesClass","PointClass","pointClass","ScatterSeries","types","scatter","Axis","Chart","Series","MarkerClusters_MarkerClusterSymbols","SVGRendererClass","SVGRenderer"],"mappings":"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"}